# 数据结构复习

英文单词：fixed(固定)  aggregate(聚合) variable(可变的) 

#### 什么是数据结构：

一般来说，用计算机解决问题一个具体问题的时，大致需要经过下列几个步骤：

1. 首先从具体问题抽象出一个适当的数据模型；
2. 设计一个解决此数学模型的算法；
3. 编写程序，测试，调整直至得到最终解答；

但是，很多非数值问题没法用数学方程描述，例如：图书馆检索数目系统（计算机处理的对象之间存在着一种最简单的线性关系）、计算机和人对弈问题（处理的对象衍生成树根到叶子间寻找各种格局的问题）、多叉路交通灯管理问题（处理对象衍生成图染色问题）。
因此，数据结构，简单来说：就是一门研究非数值计算问题的程序设计问题中计算机的操作对象以及他们之间关系和操作等的学科。

> 程序设计的实质：对确定的问题选择一种好的结构，加上设计一种好的算法。

#### 专业术语：

- 数据：对客观事物的符号表示，CS中指所有能输入到计算机中并被计算机程序处理的符号总称；
- 数据元素：数据的基本单位，CS中作为一个整体进行考虑和处理，由若干数据项组成；
- 数据对象：性质相同的数据元素的集合，数据的子集；
- 数据结构：相互之间存在一种或多种特定关系的数据元素的集合；
- 结构（逻辑结构）：数据元素相互之间的关系（逻辑关系）；根据数据元素间的不同关系，通常有以下四类基本结构：
  - 集合：结构中的元素，除了==同属于一个集合==外，再没有其他关系；
  - 线性结构：数据元素间存在==一个对一个==的关系；
  - 树形结构：结构中的数据元素之间存在==一个对多个==的关系；
  - 图状结构（网状结构）：结构中的数据元素之间存在==多个对多个==的关系；

#### 在计算机中的表示：

数据结构在计算机中的表示（又称==映像==）称为数据的==物理结构==（存储结构），数据元素之间的关系在计算机中只有两种不同的表示方法：顺序映像 和 非顺序映像；由此得到两种存储结构：顺序存储结构 和 非顺序存储结构。

计算机中表示信息的最小单位是二进制的一位，叫做**位**，计算机中我们用一个由若干位组合起来的位串表示一个数据元素（如用8位表示一个字符），通常称这个位串为**元素**或**结点**，当数据元素由若干数据项组成时，位串中对应于各个数据项的子位串称为**数据域**。

> 任何一个好的算法的设计取决于选定的数据逻辑结构，算法的实现依赖于次啊用的存储结构。

数据类型：明显隐含在程序执行期间变量或表达式所有可能取值的范围，以及这些值上允许进行的操作。也就是一个值的集合和定义在这个值集上的一组操作的总称。高级程序语言中，数据类型分为类，分为：非结构的原子类（基本类型，指针，空类型等）和结构类型。
一般编程语言里，数据元素名（a,b,c,d,e)，整形变量名（i,j,k,l,m,n), 指针变量名（p,q,r)。

引入数据类型的目的：从硬件角度看，是作为解释计算机内存中信息含义的一种手段；对用户来说，实现信息隐蔽，将不必了解的细节封装在类型里。

#### 算法

算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中一条指令表示一个或多个操作。

五个重要特性：

1. 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成；
2. 确定性：算法中的每一条指令必须有确切的含义，读者理解不会产生二义性，并且在任何条件下，算法只有惟一的一条执行路径，即对于相同的输入只能得出相同输出；
3. 可行性：一个算法是能行的，即算法中描述的操作都是可以通多已经实现的基本运算执行有限次来实现的；
4. 输入：一个算法有零个或多个的输入，这些输入取自于某个特定对象的集合；
5. 输出：一个算法有一个或者多个输出，这些输出和同输入有着特定关系；

好的算法设计要求：

1. 正确性；
2. 可读性；
3. 健壮性；
4. 效率和低存储量需求；
   效率的度量一般采用==渐近时间复杂度==来描述，一般时间复杂度指最坏时间复杂度（因为平均时间复杂度难以确定）。存储量需求用空间复杂度描述，所需要的额外空间对于输入数据量来说是常数，则称此算法为**原地工作**



## 线性表

线性结构特点：

1. 存在唯一一个被称为第一个的数据元素；
2. 存在唯一一个被称为最后一个的数据元素；
3. 除第一个之外，集合中的每个数据元素均只有一个前驱；
4. 除最后一个之外，集合中的每个数据元素均只有一个后继；

线性表：是n个数据元素的有限序列。

复杂的线性表中，一个数据元素由若干个数据项组成，在此情况下，数据元素又称之为**记录**（record），含有大量记录的线性表称之为文件。

### 实现

顺序实现：**l**表示一个元素所占用的存储空间
$$
LOC(a_{i+1}) = LOC(a_i) + l
$$

```c++
#define LISTINCREMENT 10
#define LIST_INIT_SIZE 100
#define int ElemType

// 顺序表
typedef struct {
    ElemType *elem;
    int length;
    int listsize;
}SqList;

// 单链表
typedef struct LNode {
    ElemType data;
    struct LNode* next;
}LNode, *LinkList;
```

单链表由头指针唯一确定，有时候为了方便，可以在第一个节点前附设一个节点，称之为==头节点==，头结点的数据域可以不存任何东西，也可以存辅助信息，指针域存储指向第一个节点的指针。

#### 循环链表

操作和单链表基本一致，差别在于算法中循环条件判断不是p或者p->next是否为空，而是是否等于头指针。有时候在循环链表中设立尾指针而不设头指针，可以使操作简化。

#### 双向链表

结点中有两个指针域，一个指向直接后继，一个指向直接前驱。





## 栈

栈是限定在表尾进行插入或者删除操作的线性表。

表尾有特殊含义称之为==栈顶(top)==，表头称为栈底，不含元素的为空栈。

**FIFO：后进先出。**

基本操作：

1. 栈顶插入；push()
2. 栈顶删除；pop()
3. 栈的初始化；
4. 判空；empty()
5. 取栈顶元素；top()

应用：

1. 数值转换；
2. 括号匹配校验；
3. 行编辑程序；
4. 迷宫求解；
5. 表达式求值；
6. 递归栈的应用；

## 队列

队列是限定在表的一端进行插入，另一端进行删除的线性表。

**FIFO：先进先出。**

允许插入的一端叫==队尾(rear)==，允许删除的一端叫==队头(front)==。

#### 双端队列

限定插入删除在两端进行。

#### 循环队列

将顺序队列臆造称一个环状的空间，称之为循环队列。

但是这样不能根据`Q.front == Q.rear`判断队列是否为空或满，有两种处理办法：

1. 另设一个标志位以区别队列为“空”，还是“满”；
2. 少用一个元素空间，约定队列头指针在队列尾指针的下一位置上作为队列呈“满”状态标识。

```cpp
typedef ElemType* List;

#define MAXSIZE 100
typedef struct {
    int* base;
    int front;
    int rear;
}SqQueue;

int InitQueue(SqQueue &Q) {
    Q.base = (int *)malloc(sizeof(int) * MAXSIZE);
    if (!Q.base) exit(OVERFLOW);
    Q.front = Q.rear = 0;
    return OK;
}

int QueueLength(SqQueue Q) {
    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}

// 规定front永远在rear的下一位置，少用一个元素空间
int EnQueue(SqQueue &Q, int e) {
    if ((Q.rear+1) % MAXSIZE == Q.front) return ERROR;
    Q.base[Q.rear] = e;
    Q.rear = (Q.rear+1) % MAXSIZE;
    return OK;
}

int DeQueue(SqQueue &Q, int &e) {
    if (Q.rear == Q.front) return ERROR;
    e = Q.base[Q.front];
    Q.front = (Q.front + 1) % MAXSIZE;
    return OK;
}
```





## 串

